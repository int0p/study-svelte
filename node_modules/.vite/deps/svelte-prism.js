import "./chunk-HHZ3SLF4.js";
import {
  require_prism
} from "./chunk-O5B7MRES.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  binding_callbacks,
  children,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_text,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  init,
  insert_hydration_dev,
  safe_not_equal,
  set_data_dev,
  set_style,
  space,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-UJLIVLOQ.js";
import {
  __toESM
} from "./chunk-DFKQJ226.js";

// node_modules/svelte-prism/src/beforeImport.js
if (typeof window !== "undefined") {
  if (window.Prism)
    console.warn(
      "Prism has already been initiated. Please ensure that svelte-prism is imported first."
    );
  window.Prism = window.Prism || {};
  window.Prism.manual = true;
}

// node_modules/svelte-prism/src/import.js
var import_prismjs = __toESM(require_prism());
var import_default = import_prismjs.default;

// node_modules/svelte-prism/src/Prism.svelte
var file = "node_modules/svelte-prism/src/Prism.svelte";
function create_else_block(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*formattedCode*/
        ctx[2],
        target,
        anchor
      );
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*formattedCode*/
      4)
        html_tag.p(
          /*formattedCode*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(32:45) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*formattedCode*/
        ctx[2]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*formattedCode*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*formattedCode*/
      4)
        set_data_dev(
          t,
          /*formattedCode*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: '(32:5) {#if language === \\"none\\"}',
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let code0;
  let t;
  let pre;
  let code1;
  let code1_class_value;
  let pre_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*language*/
      ctx2[0] === "none"
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      code0 = element("code");
      if (default_slot)
        default_slot.c();
      t = space();
      pre = element("pre");
      code1 = element("code");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      code0 = claim_element(nodes, "CODE", { style: true });
      var code0_nodes = children(code0);
      if (default_slot)
        default_slot.l(code0_nodes);
      code0_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      pre = claim_element(nodes, "PRE", {
        class: true,
        "command-line": true,
        "data-output": true
      });
      var pre_nodes = children(pre);
      code1 = claim_element(pre_nodes, "CODE", { class: true });
      var code1_nodes = children(code1);
      if_block.l(code1_nodes);
      code1_nodes.forEach(detach_dev);
      pre_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(code0, "display", "none");
      add_location(code0, file, 26, 0, 727);
      attr_dev(code1, "class", code1_class_value = "language-" + /*language*/
      ctx[0]);
      add_location(code1, file, 30, 65, 860);
      attr_dev(pre, "class", pre_class_value = "language-" + /*language*/
      ctx[0]);
      attr_dev(pre, "command-line", "");
      attr_dev(pre, "data-output", "2-17");
      add_location(pre, file, 30, 0, 795);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, code0, anchor);
      if (default_slot) {
        default_slot.m(code0, null);
      }
      ctx[7](code0);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, pre, anchor);
      append_hydration_dev(pre, code1);
      if_block.m(code1, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(code1, null);
        }
      }
      if (!current || dirty & /*language*/
      1 && code1_class_value !== (code1_class_value = "language-" + /*language*/
      ctx2[0])) {
        attr_dev(code1, "class", code1_class_value);
      }
      if (!current || dirty & /*language*/
      1 && pre_class_value !== (pre_class_value = "language-" + /*language*/
      ctx2[0])) {
        attr_dev(pre, "class", pre_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(code0);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(pre);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var prism2 = import_default;
var highlight = import_default.highlightElement;
var globalConfig = { transform: (x) => x };
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Prism", slots, ["default"]);
  let { language = "javascript" } = $$props;
  let { source = "" } = $$props;
  let { transform = (x) => x } = $$props;
  let element2, formattedCode;
  function highlightCode() {
    const grammar = prism2.languages[language];
    let body = source || element2.textContent;
    body = globalConfig.transform(body);
    body = transform(body);
    $$invalidate(2, formattedCode = language === "none" ? body : prism2.highlight(body, grammar, language));
  }
  function code0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("language" in $$new_props)
      $$invalidate(0, language = $$new_props.language);
    if ("source" in $$new_props)
      $$invalidate(3, source = $$new_props.source);
    if ("transform" in $$new_props)
      $$invalidate(4, transform = $$new_props.transform);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _prism: import_default,
    prism: prism2,
    highlight,
    globalConfig,
    language,
    source,
    transform,
    element: element2,
    formattedCode,
    highlightCode
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("language" in $$props)
      $$invalidate(0, language = $$new_props.language);
    if ("source" in $$props)
      $$invalidate(3, source = $$new_props.source);
    if ("transform" in $$props)
      $$invalidate(4, transform = $$new_props.transform);
    if ("element" in $$props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("formattedCode" in $$props)
      $$invalidate(2, formattedCode = $$new_props.formattedCode);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$props && (source || element2) && highlightCode();
  };
  $$props = exclude_internal_props($$props);
  return [
    language,
    element2,
    formattedCode,
    source,
    transform,
    $$scope,
    slots,
    code0_binding
  ];
}
var Prism = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { language: 0, source: 3, transform: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Prism",
      options,
      id: create_fragment.name
    });
  }
  get language() {
    throw new Error("<Prism>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set language(value) {
    throw new Error("<Prism>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get source() {
    throw new Error("<Prism>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<Prism>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transform() {
    throw new Error("<Prism>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transform(value) {
    throw new Error("<Prism>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Prism_default = Prism;
export {
  Prism_default as default,
  globalConfig,
  highlight,
  prism2 as prism
};
//# sourceMappingURL=svelte-prism.js.map
